# JavaScript Programming [^1]

## How do you program in JavaScript?

From Wikipedia:

...

... supporting **object-oriented**, **imperative**, and **functional programming**

...

- Originally programming conventions (i.e. patterns) rather than language features

- ECMAScript adding language features (e.g. class, => , etc.)

## Object-oriented programming: methods

- With first class functions a property of an object can be a function

  ```javascript
  let obj = {count: 0};
  obj.increment = function (amount) {
    this.count += amount;
    return this.count; 
  }
  ```

- Method invocation: calls function and binds this to be object

  ```javascript
  obj.increment(1); // returns 1
  obj.increment(3);  // returns 4
  ```
  
## this

- In methods this will be bound to the object

  ```javascript
    let o = {oldProp: 'this is an old property'};
    o.aMethod = function() {
      this.newProp = "this is a new property";
      return Object.keys(this);  // will contain 'newProp'
    }
    o.aMethod(); // will return ['oldProp','aMethod','newProp']
  ```

- In non-method functions
  - this will be the global object
  - Or if `"use strict";` this will be undefined

## functions are objects - can have properties

  ```javascript
      function plus1(value) {
        if (plus1.invocations == undefined) {
            plus1.invocations = 0;
        }
        plus1.invocations++;
        return value + 1;
    }
  ```
  
  - `plus1.invocations` will be the number times function is called
  - Acts like static/class properties in object-oriented languages

## function are objects: Have methods

  ```javascript
  function func(arg) { console.log(this,arg); }
  ```
  
  - `toString()` method - return function as source string
    - `func.toString()` returns 'function func(arg) { console.log(this,arg); }' 
  - `call()` method - call function specifying this and arguments
    - `func.call({t: 1}, 2)` prints '{ t: 1 } 2'
    -  `apply()` like `call()` except arguments are passed as an array - `func.apply({t: 2},[2])`
    -  `this` is like an extra hidden argument to a function call and is used that way sometimes
  - `bind()` method - creates a new function with this and arguments bound
    - let newFunc = func.bind({z: 2}, 3);
    - newFunc() prints '{ z: 2 } 3'

## Object-oriented programming: classes

Functions are classes in JavaScript: Name the function after the class

```javascript
  function Rectangle(width, height) {
     this.width = width;
     this.height = height;
     this.area = function() { return this.width*this.height; } // Not correct way of adding methods
  }
  let r = new Rectangle(26, 14); // {width: 26, height: 14}
```

Functions used in this way are called constructors

```javascript
  console.log(r.constructor.name === 'Rectangle') //prints true
  console.log(r) //prints Rectangle { width: 26, height: 14, area: [Function (anonymous)] }
```

## Object-oriented programming: inheritance

- Javascript has the notion of a **prototype** object for each object instance
- Prototype objects can have prototype objects forming a **prototype chain**

  object $\rightarrow$ prototype $\rightarrow$ prototype $\rightarrow$ ... prototype $\rightarrow$ null

- On an object property read access, JavaScript will search up the prototype chain until the property is found
- Effectively the properties of an object are its own property in addition to all the properties up the prototype chain. This is called prototype-based inheritance.
- Property updates are different: always create property in object if not found

## Using Prototypes

```javascript
    function Rectangle(width, height) {
        this.width = width;
        this.height = height;
    }
    Rectangle.prototype.area = function() {
       return this.width*this.height;
    }
    let r = new Rectangle(26, 14); // {width: 26, height: 14} 
    let v = r.area(); // v == 26*14
    console.log(Object.keys(r)) //prints [ 'width', 'height' ]
```

Note: Dynamic - changing prototype will cause all instances to change
  
## Prototype versus object instances

```javascript
  let r = new Rectangle(26, 14);
  
  r.newMethod1 = function() { console.log('New Method 1 called'); }
  Rectangle.prototype.newMethod2 = function() { console.log('New Method 2 called'); }
  
  r.newMethod1() // prints New Method 1 called
  r.newMethod2() // prints New Method 2 called
  
  let s = new Rectangle(10, 20);
  
  s.newMethod1() //error because newMethod1 doesn't exist
  s.newMethod2() // prints New Method 2 called
  
```

[^1]: [Stanford Computer Science](https://cs.stanford.edu)
